module Control.Algebra.Properties where

import Prelude
import Data.HeytingAlgebra (implies)

absorbtion ∷ ∀ a. Eq a ⇒ (a → a → a) → (a → a → a) → a → a → Boolean
absorbtion f g a b = a `f` (a `g` b) == a && a `g` (a `f` b) == a

leftAlternativeIdentity ∷ ∀ a. Eq a ⇒ (a → a → a) → a → a → Boolean
leftAlternativeIdentity op a b = a `op` (a `op` b) == (a `op` a) `op` b

rightAlternativeIdentity ∷ ∀ a. Eq a ⇒ (a → a → a) → a → a → Boolean
rightAlternativeIdentity op a b = (b `op` a) `op` a == b `op` (a `op` a)

alternativeIdentity ∷ ∀ a. Eq a ⇒ (a → a → a) → a → a → Boolean
alternativeIdentity op a b = leftAlternativeIdentity  op a b
                          && rightAlternativeIdentity op a b

anticommutative ∷ ∀ a b. Eq b ⇒ (a → a → b) → a → a → Boolean
anticommutative op a b = a `op` b /= b `op` a

antireflexive ∷ ∀ a b. HeytingAlgebra b ⇒ Eq b ⇒ (a → a → b) → a → b
antireflexive = not <<< reflexive

asymmetric ∷ ∀ a. Eq a ⇒ (a → a → Boolean) → a → a → Boolean
asymmetric op a b = (a `op` b) `implies` (not (b `op` a))

antisymmetric ∷ ∀ a. Eq a ⇒ (a → a → Boolean) → a → a → Boolean
antisymmetric op a b = (a `op` b && b `op` a) `implies` (a == b)

antitransitive ∷ ∀ a b. HeytingAlgebra b ⇒ (a → a → b) → a → a → a → b
antitransitive op a b c = (a `op` b && b `op` c) `implies` (not (a `op` c))

associative ∷ ∀ a. Eq a ⇒ (a → a → a) → a → a → a → Boolean
associative op a b c = a `op` (b `op` c) == (a `op` b) `op` c

leftCancellative ∷ ∀ a. Eq a ⇒ (a → a → a) → a → a → a → Boolean
leftCancellative op a b c = (a `op` b == a `op` c) `implies` (b == c)

rightCancellative ∷ ∀ a. Eq a ⇒ (a → a → a) → a → a → a → Boolean
rightCancellative op a b c = (b `op` a == c `op` a) `implies` (b == c)

cancellative ∷ ∀ a. Eq a ⇒ (a → a → a) → a → a → a → Boolean
cancellative op a b c = leftCancellative op a b c && rightCancellative op a b c

commutative ∷ ∀ a b. Eq b ⇒ (a → a → b) → a → a → Boolean
commutative op a b = a `op` b == b `op` a

congruent ∷ ∀ a. Eq a ⇒ (a → a) → a → a → Boolean
congruent f a b = (a == b) `implies` (f a == f b)

elasticIdentity ∷ ∀ a. Eq a ⇒ (a → a → a) → a → a → Boolean
elasticIdentity op a b = flexibleIdentity op a b && jordanIdentity op a b
                      && (a `op` (a `op` a) `op` b == (a `op` a) `op` (a `op` b))

leftDistributive
  ∷ ∀ a. Eq a ⇒ (a → a → a) → (a → a → a) → a → a → a → Boolean
leftDistributive f g a b c = a `f` (b `g` c) == (a `f` b) `g` (a `f` c)

rightDistributive
  ∷ ∀ a. Eq a ⇒ (a → a → a) → (a → a → a) → a → a → a → Boolean
rightDistributive f g a b c = (a `f` b) `g` c == (a `g` c) `f` (b `g` c)

distributive ∷ ∀ a. Eq a ⇒ (a → a → a) → (a → a → a) → a → a → a → Boolean
distributive f g a b c =
  leftDistributive f g a b c && rightDistributive f g a b c

falsehoodPreserving ∷ ∀ a. HeytingAlgebra a ⇒ Eq a ⇒ (a → a → a) → a → a → a
falsehoodPreserving op a b = (a `op` b) `implies` (a || b)

flexibleIdentity ∷ ∀ a. Eq a ⇒ (a → a → a) → a → a → Boolean
flexibleIdentity op a b = (a `op` b) `op` a == a `op` (b `op` a)

idempotent ∷ ∀ a. Eq a ⇒ (a → a) → a → Boolean
idempotent op a = op (op a) == a

idempotent' ∷ ∀ a. Eq a ⇒ (a → a → a) → a → Boolean
idempotent' op a = a `op` a == a

identity ∷ ∀ a. Eq a ⇒ (a → a → a) → a → a → Boolean
identity op id a = a `op` id == a

intransitive ∷ ∀ a b. HeytingAlgebra b ⇒ (a → a → b) → a → a → a → b
intransitive = not <<< transitive

involution ∷ ∀ a. Eq a ⇒ (a → a) → a → Boolean
involution f a = f (f a) == a

jacobiIdentity ∷ ∀ a. Eq a ⇒ (a → a → a) → (a → a → a) → a → a → a → a → Boolean
jacobiIdentity sum product additiveId a b c =
  (a `product` (b `product` c)) `sum`
  (b `product` (c `product` a)) `sum`
  (c `product` (a `product` b)) == additiveId

jordanIdentity ∷ ∀ a. Eq a ⇒ (a → a → a) → a → a → Boolean
jordanIdentity op a b = (a `op` b) `op` (a `op` a) == a `op` (b `op` (a `op` a))

medial ∷ ∀ a. Eq a ⇒ (a → a → a) → a → a → a → a → Boolean
medial op a b c d = (a `op` b) `op` (c `op` d) == (a `op` c) `op` (b `op` d)

monotonic ∷ ∀ a. HeytingAlgebra a ⇒ Eq a ⇒ (a → a → a) → a → a → a → a
monotonic op a b c = (a `implies` b) `implies` ((a `op` c) `implies` (b `op` c))

-- | A magma M is power-associative if the subalgebra generated by any
-- | element is associative.
-- |
-- | ∀ m n.   m,n ∈ ℤ+   x^m • x^n = x^(m + n)
-- | where x^m • x^n is defined recursively via x^1 = x, x^(n + 1) = x^n • x
powerAssociative ∷ ∀ a. Eq a ⇒ (a → a → a) → a → Boolean
powerAssociative op a = a `op` (a `op` a) == (a `op` a) `op` a

reflexive ∷ ∀ a b. HeytingAlgebra b ⇒ Eq b ⇒ (a → a → b) → a → b
reflexive op a = a `op` a

leftSemimedial ∷ ∀ a. Eq a ⇒ (a → a → a) → a → a → a → a → Boolean
leftSemimedial op a b c d = (a `op` a) `op` (b `op` c)
                         == (a `op` b) `op` (a `op` c)

rightSemimedial ∷ ∀ a. Eq a ⇒ (a → a → a) → a → a → a → a → Boolean
rightSemimedial op a b c d = (b `op` c) `op` (a `op` a)
                          == (b `op` a) `op` (c `op` a)

semimedial ∷ ∀ a. Eq a ⇒ (a → a → a) → a → a → a → a → Boolean
semimedial op a b c d = leftSemimedial op a b c d && rightSemimedial op a b c d

transitive ∷ ∀ a b. HeytingAlgebra b ⇒ (a → a → b) → a → a → a → b
transitive op a b c = (a `op` b && b `op` c) `implies` (a `op` c)

truthPreserving ∷ ∀ a. HeytingAlgebra a ⇒ Eq a ⇒ (a → a → a) → a → a → a
truthPreserving op a b = (a && b) `implies` (a `op` b)

leftUnar ∷ ∀ a. Eq a ⇒ (a → a → a) → a → a → a → Boolean
leftUnar op a b c = a `op` b == a `op` c

rightUnar ∷ ∀ a. Eq a ⇒ (a → a → a) → a → a → a → Boolean
rightUnar op a b c = b `op` a == c `op` a

unipotent ∷ ∀ a. Eq a ⇒ (a → a → a) → a → a → Boolean
unipotent op a b = a `op` a == b `op` b

zeropotent ∷ ∀ a. Eq a ⇒ (a → a → a) → a → a → Boolean
zeropotent op a b = (a `op` a) `op` b == a `op` (b `op` b)
                 && (a `op` a) `op` b == a `op` a
