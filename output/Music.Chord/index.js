// Generated by purs version 0.11.7
"use strict";
var Data_Array = require("../Data.Array");
var Data_Either = require("../Data.Either");
var Data_Eq = require("../Data.Eq");
var Data_Foldable = require("../Data.Foldable");
var Data_Functor = require("../Data.Functor");
var Data_Maybe = require("../Data.Maybe");
var Data_Monoid = require("../Data.Monoid");
var Data_Semigroup = require("../Data.Semigroup");
var Data_Show = require("../Data.Show");
var Music_Extension = require("../Music.Extension");
var Music_Key = require("../Music.Key");
var Music_Mode = require("../Music.Mode");
var Music_Note = require("../Music.Note");
var Music_Scale = require("../Music.Scale");
var Music_Transpose = require("../Music.Transpose");
var Prelude = require("../Prelude");
var Chord = (function () {
    function Chord(value0, value1, value2) {
        this.value0 = value0;
        this.value1 = value1;
        this.value2 = value2;
    };
    Chord.create = function (value0) {
        return function (value1) {
            return function (value2) {
                return new Chord(value0, value1, value2);
            };
        };
    };
    return Chord;
})();
var transpose_chord = new Music_Transpose.Transpose(function (n) {
    return function (v) {
        return new Chord(Music_Transpose.trans(Music_Note.transpose_pitchclass)(n)(v.value0), v.value1, v.value2);
    };
});
var mk_markup = function (root) {
    return function (mode) {
        return function (exts) {
            var mk_exts = function (x) {
                return function (y) {
                    return {
                        root: Data_Show.show(Music_Note.show_pitchclass)(root),
                        mode: mode,
                        head_ext: x,
                        tail_ext: y
                    };
                };
            };
            var bracket = function (x) {
                return "(" + (x + ")");
            };
            var v = Data_Array.uncons(Data_Functor.map(Data_Functor.functorArray)(Data_Show.show(Music_Extension.show_extension))(exts));
            if (v instanceof Data_Maybe.Just) {
                return mk_exts(v.value0.head)(Data_Functor.map(Data_Functor.functorArray)(bracket)(v.value0.tail));
            };
            if (v instanceof Data_Maybe.Nothing) {
                return mk_exts("")([  ]);
            };
            throw new Error("Failed pattern match at Music.Chord line 48, column 28 - line 50, column 44: " + [ v.constructor.name ]);
        };
    };
};
var markup = function (v) {
    if (v.value1 instanceof Music_Mode.Major && v.value2.length === 0) {
        return mk_markup(v.value0)("")([  ]);
    };
    if (v.value1 instanceof Music_Mode.Major) {
        return mk_markup(v.value0)("maj")(v.value2);
    };
    if (v.value1 instanceof Music_Mode.Minor) {
        return mk_markup(v.value0)("m")(v.value2);
    };
    if (v.value1 instanceof Music_Mode.Mixolydian) {
        return mk_markup(v.value0)("")(v.value2);
    };
    if (v.value1 instanceof Music_Mode.Diminished) {
        return mk_markup(v.value0)("dim")(v.value2);
    };
    if (v.value1 instanceof Music_Mode.Augmented) {
        return mk_markup(v.value0)("aug")(v.value2);
    };
    return mk_markup(v.value0)("???")(v.value2);
};
var eq_chord = new Data_Eq.Eq(function (c1) {
    return function (c2) {
        return true;
    };
});
var chord_suffix = function (chord) {
    var m = markup(chord);
    return m.mode + (m.head_ext + Data_Foldable.fold(Data_Foldable.foldableArray)(Data_Monoid.monoidString)(m.tail_ext));
};
var show_chord = new Data_Show.Show(function (chord) {
    var m = markup(chord);
    return m.root + chord_suffix(chord);
});
module.exports = {
    Chord: Chord,
    chord_suffix: chord_suffix,
    markup: markup,
    mk_markup: mk_markup,
    eq_chord: eq_chord,
    show_chord: show_chord,
    transpose_chord: transpose_chord
};
